# 自动化部署脚本（从push到上线5分钟）

**作者**: Cline | **发布日期**: 2025-10-30 | **分类**: `核心技术栈` `DevOps` `CI/CD` `自动化`

**摘要**: 手动部署是重复、易错且低效的代名词。在现代软件开发中，自动化部署是衡量一个团队工程能力成熟度的关键指标。本文将为你揭示如何从零开始，构建一个轻量级、高效的“Git Push to Deploy”自动化流水线。我们将编写一个超过100行的健壮`deploy.sh`部署脚本，它负责拉取代码、重建Docker镜像、优雅地重启服务并清理旧资源。更进一步，我们将创建一个安全的Node.js Webhook监听服务，用于接收来自GitHub或GitLab的推送事件，并自动触发部署脚本。跟随本教程，你将能实现“代码一推送，五分钟内自动上线”的梦想，彻底告别繁琐的手动部署。

**SEO关键词**: 自动化部署脚本, Git Push to Deploy, Webhook部署, Shell脚本部署, Node.js Webhook, Docker自动化, CI/CD从零实现

---

## 第1部分：告别“人肉运维”：自动化部署的价值

在项目的早期，我们可能习惯于这样的流程：
1.  `ssh user@your-server.com`
2.  `cd /var/www/my-app`
3.  `git pull origin main`
4.  `docker-compose down && docker-compose up --build -d`
5.  手动检查一下网站是否正常。

这个流程在偶尔为之时还可接受，但随着迭代频率的增加，其弊端暴露无遗：
-   **效率低下**: 每次部署都耗费开发者宝贵的时间。
-   **容易出错**: 手动操作，总有输错命令或遗漏步骤的风险。
-   **不一致性**: 无法保证每次部署的环境和流程完全相同。
-   **权限风险**: 需要将服务器的SSH权限分发给多个开发者。

**自动化部署的目标**: 将上述手动流程，封装成一个由`git push`事件自动触发的、可靠的、无人值守的脚本。

---

## 第2部分：蓝图设计：构建自动化部署流水线

我们的自动化流水线由三个核心组件构成：

1.  **Git仓库 (GitHub/GitLab)**: 作为代码的唯一信源。我们将配置一个**Webhook**，当`main`分支有新的`push`事件时，它会向我们的服务器发送一个HTTP POST请求。
2.  **Webhook监听服务 (部署在服务器上)**: 这是一个轻量级的、长期运行的HTTP服务。它的唯一职责就是监听来自Git仓库的Webhook请求，验证请求的合法性，然后执行我们的部署脚本。
3.  **部署脚本 (部署在服务器上)**: 这是一个Shell脚本，包含了完整的部署逻辑：拉取最新代码、构建Docker镜像、重启服务、健康检查和清理工作。

**工作流程图**:
`Developer` -> `git push` -> `GitHub/GitLab` -> `Webhook (HTTP POST)` -> `Webhook Listener (on Server)` -> `Executes deploy.sh` -> `Application is Live`

---

## 第3部分：核心武器：编写健壮的部署脚本

这是我们自动化流程的执行核心。一个好的部署脚本应该是**幂等**的（多次运行结果一致）和**健壮**的。

**项目前提**:
-   你的项目已经Docker化，并使用`docker-compose.yml`进行编排。
-   你的服务器上已经安装了`git`, `docker`, `docker-compose`。
-   你的项目代码通过Git部署在服务器的某个目录（例如`/var/www/my-app`）。

`deploy.sh`:
```bash
#!/bin/bash

# deploy.sh: 自动化部署脚本
#
# 该脚本执行以下操作:
# 1. 检查必要的环境变量。
# 2. 导航到项目目录。
# 3. 从Git拉取最新代码。
# 4. 使用Docker Compose构建和重启服务。
# 5. 执行部署后健康检查。
# 6. 清理悬空的Docker镜像。

# --- 配置 ---
# 设置项目目录
PROJECT_DIR="/var/www/my-app"
# 设置Docker Compose文件名
COMPOSE_FILE="docker-compose.prod.yml"
# 设置健康检查URL
HEALTH_CHECK_URL="http://localhost:80"
# Git分支
GIT_BRANCH="main"

# --- 颜色定义 ---
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# --- 函数定义 ---
log_info() {
    echo -e "${GREEN}[INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1${NC}"
}

log_error() {
    echo -e "${RED}[ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $1${NC}"
}

log_warn() {
    echo -e "${YELLOW}[WARN] $(date '+%Y-%m-%d %H:%M:%S') - $1${NC}"
}

# --- 脚本主逻辑 ---

# 步骤 0: 设置脚本在任何命令失败时立即退出
set -e

log_info "===== Starting deployment ====="

# 步骤 1: 导航到项目目录
log_info "Navigating to project directory: ${PROJECT_DIR}"
cd ${PROJECT_DIR}

# 步骤 2: 拉取最新代码
log_info "Pulling latest code from branch '${GIT_BRANCH}'..."
git fetch origin ${GIT_BRANCH}
git reset --hard origin/${GIT_BRANCH}
git pull origin ${GIT_BRANCH}

# 步骤 3: 使用Docker Compose构建和重启服务
log_info "Building and restarting services using ${COMPOSE_FILE}..."
# --build: 强制重新构建镜像
# -d: 在后台运行
# --remove-orphans: 移除在compose文件中已不存在的服务的容器
docker-compose -f ${COMPOSE_FILE} up --build -d --remove-orphans

# 步骤 4: 部署后健康检查
log_info "Performing health check on ${HEALTH_CHECK_URL}..."
# 等待几秒钟让服务完全启动
sleep 15

# 尝试最多5次，每次间隔10秒
for i in {1..5}; do
    # 使用curl的--fail选项，如果HTTP状态码不是2xx，则返回错误
    if curl -s --fail ${HEALTH_CHECK_URL} > /dev/null; then
        log_info "Health check passed!"
        HEALTH_CHECK_STATUS="success"
        break
    else
        log_warn "Health check attempt $i failed. Retrying in 10 seconds..."
        sleep 10
    fi
    HEALTH_CHECK_STATUS="failed"
done

if [ "$HEALTH_CHECK_STATUS" != "success" ]; then
    log_error "Application health check failed after multiple attempts. Deployment may be unstable."
    # 在这里可以添加回滚逻辑或发送告警
    # exit 1 # 如果希望健康检查失败时中止脚本，则取消此行注释
fi

# 步骤 5: 清理悬空的Docker镜像
log_info "Cleaning up dangling Docker images..."
# `docker image prune -f`会删除所有没有标签的镜像
docker image prune -f

log_info "===== Deployment finished successfully! ====="

exit 0
```
**使用方法**:
1.  将此脚本保存到服务器的某个位置，例如`/opt/scripts/deploy.sh`。
2.  赋予执行权限: `chmod +x /opt/scripts/deploy.sh`。
3.  确保运行此脚本的用户有权限执行`git`和`docker`命令。

---

## 第4部分：神经中枢：创建Webhook监听服务

这个服务是连接Git和部署脚本的桥梁。我们将使用Node.js和Express来创建一个简单的监听器。

**项目结构**:
```
webhook-listener/
├── Dockerfile
├── index.js
└── package.json
```

`package.json`:
```json
{
  "name": "webhook-listener",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": { "start": "node index.js" },
  "dependencies": {
    "express": "^4.18.2",
    "body-parser": "^1.20.2",
    "crypto": "^1.0.1",
    "child_process": "^1.0.2"
  }
}
```

`index.js`:
```javascript
const express = require('express');
const bodyParser = require('body-parser');
const crypto = require('crypto');
const { exec } = require('child_process');

const app = express();
const PORT = 9001; // 使用一个不常用的端口
const WEBHOOK_SECRET = 'your_super_secret_string'; // 关键：与GitHub/GitLab中设置的Secret保持一致
const DEPLOY_SCRIPT_PATH = '/opt/scripts/deploy.sh'; // 部署脚本的路径

// 使用body-parser中间件来解析JSON请求体
app.use(bodyParser.json());

app.post('/webhook/deploy', (req, res) => {
    // --- 步骤 1: 验证签名 ---
    const signature = req.headers['x-hub-signature-256'];
    if (!signature) {
        return res.status(401).send('Signature required.');
    }

    const hmac = crypto.createHmac('sha256', WEBHOOK_SECRET);
    const digest = 'sha256=' + hmac.update(JSON.stringify(req.body)).digest('hex');

    if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest))) {
        return res.status(401).send('Invalid signature.');
    }

    // --- 步骤 2: 验证通过，执行部署脚本 ---
    console.log('Webhook signature verified. Executing deployment script...');
    
    const deployProcess = exec(`sh ${DEPLOY_SCRIPT_PATH}`, (error, stdout, stderr) => {
        if (error) {
            console.error(`exec error: ${error}`);
            return;
        }
        console.log(`stdout: ${stdout}`);
        console.error(`stderr: ${stderr}`);
    });

    res.status(200).send('Webhook received. Deployment process started.');
});

app.listen(PORT, () => {
    console.log(`Webhook listener running on port ${PORT}`);
});
```
**安全要点**:
`WEBHOOK_SECRET`是保证安全的命脉。它确保了只有知道这个密钥的GitHub/GitLab才能触发你的部署，防止了恶意攻击。

**容器化监听服务**:
`Dockerfile`:
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["npm", "start"]
```

---

## 第5部分：总装与上线

现在，我们将所有组件部署到服务器上。

### 5.1 部署Webhook监听服务

在服务器上，为`webhook-listener`项目创建一个`docker-compose.yml`文件。

`docker-compose.webhook.yml`:
```yaml
version: '3.8'
services:
  listener:
    build: .
    container_name: webhook_listener
    restart: always
    ports:
      - "9001:9001"
    volumes:
      # 将服务器上的部署脚本挂载到容器内，以便exec可以访问
      # 或者，更简单的方式是，让监听器和脚本都在主机上，而不是容器里
      # 这里我们选择让监听器在容器里，但它可以执行主机上的脚本
      # 这需要将docker.sock挂载进去，并让容器内的用户有权限执行docker
      # 为了简单和安全，我们让脚本在主机上，监听器通过exec直接调用
      # 注意：这意味着脚本路径是相对于主机的
      - /opt/scripts:/opt/scripts
```
**注意**: 这里的配置非常灵活。最简单的方式是让`webhook-listener`直接在主机上用`pm2`等工具运行。如果用Docker，需要确保容器有权限执行主机上的脚本。

### 5.2 配置GitHub/GitLab Webhook

1.  **导航到仓库设置**:
    -   **GitHub**: `Settings` -> `Webhooks` -> `Add webhook`
    -   **GitLab**: `Settings` -> `Webhooks`
2.  **填写配置**:
    -   **Payload URL**: `http://your-server-ip:9001/webhook/deploy`
    -   **Content type**: `application/json`
    -   **Secret**: 输入你在`index.js`中设置的`your_super_secret_string`。**这是最重要的安全步骤！**
    -   **Which events would you like to trigger this webhook?**: 选择 `Just the push event`。
3.  **保存并测试**: 添加Webhook后，GitHub/GitLab会发送一个`ping`事件。你应该能在`webhook-listener`的日志中看到接收记录。

### 5.3 触发第一次自动化部署

一切就绪！现在，在你的本地开发机上，对你的应用项目做一个小改动，然后执行：
```bash
git add .
git commit -m "feat: trigger first auto-deployment"
git push origin main
```
回到你的服务器，通过`docker logs -f webhook_listener`查看监听器的日志，你应该能看到它接收到了请求并开始执行部署脚本。接着，你可以通过`tail -f /var/log/deploy.log`（如果将脚本输出重定向到文件）来实时观察部署的每一个步骤。

五分钟内，你的网站就更新了。你，从此解放了双手。

---

## 结论

我们从零开始，构建了一套完整、实用且安全的自动化部署流水线。这个方案虽然不如专业的CI/CD平台（如GitLab CI, Jenkins, GitHub Actions）功能丰富，但它极其轻量、易于理解和维护，对于中小型项目和个人开发者来说，是一个完美的起点。

**核心收获**:
-   **脚本化思维**: 将重复性工作封装成可执行、可复用的脚本。
-   **Webhook机制**: 理解并利用事件驱动的钩子来连接不同的系统。
-   **安全意识**: 知道如何使用签名和密钥来保护自动化流程的入口。

这套流程不仅为你节省了时间，更重要的是，它为你的项目带来了稳定性和可靠性。现在，你可以更专注于创造价值，而不是重复劳动。
