# 04.6 监控告警系统搭建：Prometheus + Grafana 实战

> “如果你无法衡量它，你就无法改进它。” 这句管理学名言在软件工程领域同样适用。一套强大的监控告警系统，是您基础设施的“眼睛”和“神经网络”，它能让您在问题影响到用户之前主动发现它们，理解系统的性能瓶颈，并基于数据做出明智的决策。本篇教程将带您从零开始，使用目前最流行的开源监控黄金组合——Prometheus（普罗米修斯）和Grafana（格拉法纳），并通过Docker Compose快速搭建一套功能完善、可扩展的监控告警平台。

**学习目标**:
- 理解Prometheus的“拉模型”(Pull Model)核心工作原理及其生态组件。
- 学会使用Docker Compose一键部署Prometheus, Grafana, Node Exporter等核心服务。
- 掌握如何采集主机、Docker容器以及自定义应用的指标。
- 熟练使用Grafana，导入并创建自己的监控仪表盘(Dashboard)。
- 掌握配置Prometheus告警规则，并通过Alertmanager发送告警通知（如发送到Slack）。

---

## 第1部分：监控黄金组合简介

### 1.1 Prometheus：新一代的监控“数据大脑”

Prometheus是一个源于SoundCloud的开源监控和告警工具包，现已成为云原生监控领域的事实标准。

- **核心理念：拉模型 (Pull Model)**
  - 与传统的监控系统（如Zabbix）由客户端（Agent）向服务器“推送(Push)”数据不同，Prometheus采用“拉(Pull)”模型。它会主动、定期地从被监控的目标上抓取（scrape）指标数据。这些被监控的目标需要通过一个HTTP端点（通常是`/metrics`）来暴露自己的指标数据。

- **核心组件**:
    - **Prometheus Server**: 核心服务，负责抓取、存储和查询时间序列数据(Time-Series Data)。
    - **Exporters (导出器)**: 用于暴露现有系统（如Linux主机、MySQL数据库、Redis等）指标的辅助程序。最常用的是`node_exporter`，用于暴露主机的硬件和操作系统指标。
    - **Alertmanager**: 负责处理由Prometheus Server发出的告警。它能对告警进行分组、去重、静默，并将其路由到不同的通知接收方（如Email, Slack, PagerDuty）。
    - **PromQL**: Prometheus内置的强大、灵活的查询语言。

### 1.2 Grafana：让数据“开口说话”的艺术家

Grafana是一个开源的数据可视化和分析平台。它本身不采集也不存储数据，而是像一个“画板”，可以接入各种不同的“数据源”（Data Source），如Prometheus, MySQL, Elasticsearch等，然后通过其强大、美观的界面，将数据以图表、仪表盘的形式展示出来。

**Prometheus + Grafana 的关系**: Prometheus负责“埋头苦干”地采集和存储海量指标数据，而Grafana则负责将这些枯燥的数据“翻译”成人类易于理解的、漂亮的图表。

---

## 第2部分：使用Docker Compose一键部署监控系统

这是在本地或单台服务器上快速搭建整套系统的最佳方式。

### 2.1 项目结构

首先，创建一个`monitoring`目录，并建立如下的结构：
```
monitoring/
├── docker-compose.yml
├── prometheus/
│   ├── prometheus.yml
│   └── rules.yml
└── alertmanager/
    └── config.yml
```

### 2.2 `docker-compose.yml` 编排文件

这是我们的“总指挥”，定义了所有需要运行的服务。

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Prometheus: 负责抓取和存储指标
  prometheus:
    image: prom/prometheus:v2.47.1
    container_name: prometheus
    restart: unless-stopped
    volumes:
      - ./prometheus:/etc/prometheus/
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
    ports:
      - "9090:9090"

  # Node Exporter: 负责暴露主机指标
  node_exporter:
    image: prom/node-exporter:v1.7.0
    container_name: node_exporter
    restart: unless-stopped
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--path.rootfs=/rootfs'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)'
    ports:
      - "9100:9100"

  # Grafana: 负责数据可视化
  grafana:
    image: grafana/grafana:10.2.0
    container_name: grafana
    restart: unless-stopped
    volumes:
      - grafana-data:/var/lib/grafana
    ports:
      - "3000:3000"

  # Alertmanager: 负责处理和发送告警
  alertmanager:
    image: prom/alertmanager:v0.26.0
    container_name: alertmanager
    restart: unless-stopped
    volumes:
      - ./alertmanager:/config
    command:
      - '--config.file=/config/config.yml'
    ports:
      - "9093:9093"

volumes:
  grafana-data: {}
```

### 2.3 `prometheus.yml` 配置文件

这是Prometheus的核心配置文件，告诉它要去哪里抓取数据。

```yaml
# prometheus/prometheus.yml
global:
  scrape_interval: 15s # 每15秒抓取一次

# 告警规则文件
rule_files:
  - "rules.yml"

# 告警管理器配置
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - 'alertmanager:9093'

# 需要抓取的目标
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'node_exporter'
    static_configs:
      - targets: ['node_exporter:9100']
```

现在，在`monitoring`目录下运行`docker-compose up -d`，你的基础监控系统就已经启动了！

- Prometheus UI: `http://localhost:9090`
- Grafana UI: `http://localhost:3000` (默认用户名/密码: `admin`/`admin`)
- Node Exporter Metrics: `http://localhost:9100/metrics`

---

## 第3部分：采集主机与应用指标

### 3.1 监控主机指标 (Node Exporter)

`node_exporter`为我们暴露了海量的操作系统和硬件指标，例如：
- `node_cpu_seconds_total`: CPU使用时间
- `node_memory_MemAvailable_bytes`: 可用内存
- `node_filesystem_avail_bytes`: 磁盘可用空间
- `node_network_receive_bytes_total`: 网络接收流量

### 3.2 监控Docker容器指标 (cAdvisor)

要监控Docker容器本身的资源使用情况，我们需要Google的`cAdvisor`。

**步骤**: 
1.  在`docker-compose.yml`中添加`cadvisor`服务：
    ```yaml
    cadvisor:
      image: gcr.io/cadvisor/cadvisor:v0.47.2
      container_name: cadvisor
      restart: unless-stopped
      volumes:
        - /:/rootfs:ro
        - /var/run:/var/run:rw
        - /sys:/sys:ro
        - /var/lib/docker/:/var/lib/docker:ro
      ports:
        - "8080:8080"
    ```
2.  在`prometheus.yml`中添加一个新的抓取任务：
    ```yaml
    - job_name: 'cadvisor'
      static_configs:
        - targets: ['cadvisor:8080']
    ```
3.  重启服务: `docker-compose up -d --force-recreate`

现在，Prometheus就会开始采集所有运行中容器的CPU、内存、网络等指标。

### 3.3 监控你自己的应用 (Instrumentation)

这是监控的精髓所在：让你的应用程序暴露自定义的业务指标。

**以Node.js (Express) 应用为例**: 
1.  安装Prometheus客户端库: `npm install prom-client`
2.  在你的代码中添加以下逻辑：
    ```javascript
    const express = require('express');
    const client = require('prom-client');
    const app = express();

    // 创建一个注册表
    const register = new client.Registry();
    register.setDefaultLabels({ app: 'my-nodejs-app' });
    client.collectDefaultMetrics({ register });

    // 创建一个自定义的HTTP请求计数器
    const httpRequestCounter = new client.Counter({
      name: 'http_requests_total',
      help: 'Total number of HTTP requests',
      labelNames: ['method', 'route', 'status_code'],
      registers: [register],
    });

    // ... 你的其他路由和中间件 ...

    // 创建一个/metrics端点，暴露指标
    app.get('/metrics', async (req, res) => {
      res.set('Content-Type', register.contentType);
      res.end(await register.metrics());
    });

    // 在响应结束后，增加计数器
    app.use((req, res, next) => {
      res.on('finish', () => {
        httpRequestCounter.inc({ 
          method: req.method, 
          route: req.route ? req.route.path : req.path, 
          status_code: res.statusCode 
        });
      });
      next();
    });

    app.listen(3001, () => console.log('App listening on port 3001'));
    ```
3.  在`prometheus.yml`中添加对该应用的抓取任务（假设应用与Prometheus在同一个Docker网络中）：
    ```yaml
    - job_name: 'my-nodejs-app'
      static_configs:
        - targets: ['host.docker.internal:3001'] # 或者你的应用容器名:端口
    ```

---

## 第4部分：Grafana可视化与仪表盘

### 4.1 添加Prometheus数据源

1.  浏览器访问`http://localhost:3000`，使用`admin`/`admin`登录。
2.  左侧菜单 -> `Connections` -> `Data sources` -> `Add new data source`。
3.  选择`Prometheus`。
4.  在`Prometheus server URL`中填入`http://prometheus:9090` (因为Grafana和Prometheus在同一个Docker网络中，可以直接使用服务名)。
5.  点击`Save & test`。

### 4.2 导入现成的仪表盘 (最快的方式)

Grafana社区有成千上万个预先制作好的仪表盘，我们可以直接导入使用。

1.  **导入Node Exporter仪表盘**: 
    - 前往 [Grafana Dashboards官网](https://grafana.com/grafana/dashboards/)，搜索“Node Exporter Full”。一个非常流行的仪表盘ID是`1860`。
    - 在Grafana左侧菜单 -> `Dashboards` -> `New` -> `Import`。
    - 在“Import via grafana.com”输入框中填入ID `1860`，点击`Load`。
    - 在下一个页面，选择你刚刚添加的Prometheus数据源，点击`Import`。
    - 瞬间，一个包含CPU、内存、磁盘、网络等所有主机指标的精美仪表盘就呈现在你眼前！

### 4.3 创建你自己的第一个图表

1.  创建一个新的Dashboard，点击`Add visualization`。
2.  在查询编辑器中，选择你的Prometheus数据源。
3.  在`Metrics browser`中输入一个PromQL查询语句。例如，计算CPU使用率：
    ```promql
    # 计算1分钟内，非空闲CPU时间的平均使用率
    1 - avg(rate(node_cpu_seconds_total{mode="idle"}[1m])) by (instance)
    ```
4.  在右侧的面板选项中，可以设置图表标题、单位（选择`Percent (0.0-1.0)`）、图例等。

---

## 第5部分：配置告警 (Alertmanager)

### 5.1 在Prometheus中定义告警规则

创建`prometheus/rules.yml`文件：
```yaml
# prometheus/rules.yml
groups:
  - name: host_alerts
    rules:
      # 当实例宕机超过1分钟时触发
      - alert: InstanceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Instance {{ $labels.instance }} down"
          description: "{{ $labels.job }} on {{ $labels.instance }} has been down for more than 1 minute."

      # 当主机CPU负载过高（超过80%）持续5分钟时触发
      - alert: HostHighCpuLoad
        expr: 100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[2m])) * 100) > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Host high CPU load on {{ $labels.instance }}"
          description: "{{ $labels.instance }} CPU load is > 80% for 5 minutes."
```

### 5.2 配置Alertmanager以发送到Slack

1.  在Slack中，创建一个App，并为其开启`Incoming Webhooks`，获取一个Webhook URL。
2.  创建`alertmanager/config.yml`文件：
    ```yaml
    # alertmanager/config.yml
    global:
      slack_api_url: 'YOUR_SLACK_WEBHOOK_URL_HERE'

    route:
      receiver: 'slack-notifications'
      group_by: ['alertname', 'instance']
      group_wait: 30s
      group_interval: 5m
      repeat_interval: 4h

    receivers:
      - name: 'slack-notifications'
        slack_configs:
          - channel: '#your-alerts-channel'
            send_resolved: true
            title: '{{ .CommonAnnotations.summary }}'
            text: '{{ .CommonAnnotations.description }}'
    ```
3.  重启服务: `docker-compose up -d --force-recreate`

现在，当Prometheus的告警规则被触发时，Alertmanager就会收到告警，并将其格式化后发送到你指定的Slack频道。

## 结论

通过Prometheus和Grafana的组合，我们用纯开源的方案，在短短几十分钟内就搭建起了一套强大的、可扩展的监控告警系统。这套系统不仅能监控基础设施，更能通过自定义指标深入到你的应用内部，为你提供前所未有的洞察力。监控不是一次性的任务，而是一个持续迭代的过程。从今天起，让数据指导你的每一次优化吧。

## 参考资料
- [Prometheus 官方文档](https://prometheus.io/docs/introduction/overview/)
- [Grafana 官方文档](https://grafana.com/docs/grafana/latest/)
- [Awesome Prometheus (各种Exporter和客户端库列表)](https://github.com/roaldnefs/awesome-prometheus)
- [prom-client (Node.js客户端库)](https://github.com/siimon/prom-client)
