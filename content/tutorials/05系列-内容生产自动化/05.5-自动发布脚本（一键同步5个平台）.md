# 05.5 自动发布脚本：一键将Markdown同步到多个平台

> 你刚刚在Obsidian或VS Code中完成了一篇精彩的技术文章，现在，噩梦开始了：你需要手动登录DEV.to, Medium, Hashnode, 掘金, CSDN等多个平台，逐一进行复制、粘贴、调整格式、上传图片……这个过程不仅枯燥、耗时、易出错，更是扼杀创作热情的“头号杀手”。本篇教程将为你提供一套终极解决方案，通过编写一个自动化的Node.js脚本，实现“一键发布”，将你的Markdown文章同步到海内外多个主流技术平台，让你从重复的体力劳动中彻底解放出来。

**学习目标**:
- 理解跨平台发布的核心挑战，特别是图片处理和平台API差异。
- 掌握如何获取并管理多个平台的API密钥。
- 学会使用Node.js编写一个预处理脚本，自动上传图片到图床并替换链接。
- 掌握如何通过执行命令行工具（如`crosspost`）来发布到支持API的平台。
- 了解如何使用浏览器自动化工具Puppeteer，搞定那些没有提供公共API的平台（如掘金、CSDN）。

---

## 第1部分：跨平台发布的挑战

1.  **API差异**: 每个平台都有自己独特的API，请求格式、认证方式各不相同。
2.  **图片处理**: 这是最大的痛点。你文章中的本地图片链接（`./images/a.png`）在其他平台上是无效的。你需要一个统一的、公开可访问的图床，并在发布前将所有本地图片链接替换为图床URL。
3.  **Canonical URL**: 为了SEO，你必须在所有转载的平台上，正确设置`canonical_url`，指向你个人博客上的原文链接，以避免搜索引擎的“重复内容”惩罚。
4.  **Markdown方言**: 各个平台对Markdown的渲染支持有细微差别，可能需要微调。

我们的策略是：**构建一个Node.js主脚本，它负责预处理Markdown（特别是图片），然后调用不同的“发布模块”来适配各个平台。**

---

## 第2部分：准备工作：API密钥与配置文件

### 2.1 获取API密钥

- **DEV.to**: `Settings` -> `Account` -> `DEV Community API Keys`。
- **Hashnode**: `Settings` -> `Developer` -> `Generate New Token`。
- **Medium**: `Settings` -> `Integration tokens`。
- **掘金 / CSDN**: 这两个平台没有提供官方的公共发布API。我们将采用**浏览器自动化**方案，通过**Cookies**来维持登录状态。
- **Cloudinary (我们的图床)**: 注册[Cloudinary](https://cloudinary.com/)，在Dashboard中可以找到你的`Cloud Name`, `API Key`, `API Secret`。

### 2.2 创建配置文件 (`config.js`)

创建一个`config.js`文件来集中管理所有密钥。**警告：必须将此文件添加到`.gitignore`中，绝对不要提交到Git仓库！**

```javascript
// config.js
// ！！！NEVER COMMIT THIS FILE TO GIT！！！

module.exports = {
  // 个人博客信息，用于生成Canonical URL
  blog: {
    url: "https://your-awesome-blog.com",
    author: "Your Name",
  },

  // 平台API密钥
  platforms: {
    devto: {
      apiKey: "YOUR_DEVTO_API_KEY",
    },
    hashnode: {
      apiKey: "YOUR_HASHNODE_API_KEY",
      publicationId: "YOUR_HASHNODE_PUBLICATION_ID", // 在后台可以找到
    },
    medium: {
      apiKey: "YOUR_MEDIUM_API_KEY",
      authorId: "YOUR_MEDIUM_AUTHOR_ID", // 在后台可以找到
    },
  },

  // 图床配置
  cloudinary: {
    cloud_name: "YOUR_CLOUDINARY_CLOUD_NAME",
    api_key: "YOUR_CLOUDINARY_API_KEY",
    api_secret: "YOUR_CLOUDINARY_API_SECRET",
  },

  // 浏览器自动化配置 (获取方式见后文)
  browser: {
    juejin: {
      cookie: "YOUR_JUEJIN_COOKIE_STRING",
    },
    csdn: {
      cookie: "YOUR_CSDN_COOKIE_STRING",
    },
  },
};
```

---

## 第3部分：核心脚本1：Markdown预处理与图片上传

这个脚本负责将一篇本地Markdown文章，转换成适合公开发布的、图片链接已全部替换的“干净”版本。

**安装依赖**: `npm install gray-matter cloudinary glob fs-extra`

```javascript
// preprocess.js
const fs = require(\'fs-extra\');
const path = require(\'path\');
const matter = require(\'gray-matter\');
const cloudinary = require(\'cloudinary\').v2;
const config = require(\'./config\');

// 配置Cloudinary
cloudinary.config(config.cloudinary);

// 上传图片到Cloudinary并返回URL
async function uploadImage(filePath) {
  try {
    const result = await cloudinary.uploader.upload(filePath, {
      folder: \'blog_assets\', // 在Cloudinary上指定的文件夹
    });
    return result.secure_url;
  } catch (error) {
    console.error(\'Error uploading image:\', error);
    return null;
  }
}

// 主处理函数
async function preprocessMarkdown(filePath) {
  const markdown = await fs.readFile(filePath, \'utf-8\');
  const { data: frontmatter, content } = matter(markdown);
  let newContent = content;

  // 1. 自动设置Canonical URL
  const slug = path.basename(filePath, \'.md\');
  frontmatter.canonical_url = `${config.blog.url}/posts/${slug}`;

  // 2. 查找并替换所有本地图片链接
  const imageRegex = /!\\[(.*?)\]\\[\(.*?)\]/g;
  const imagePromises = [];
  let match;

  while ((match = imageRegex.exec(content)) !== null) {
    const [fullMatch, altText, localPath] = match;
    const absolutePath = path.resolve(path.dirname(filePath), localPath);

    if (fs.existsSync(absolutePath)) {
      console.log(`Uploading image: ${localPath}`);
      const promise = uploadImage(absolutePath).then(url => {
        if (url) {
          console.log(`  -> Uploaded to: ${url}`);
          // 将文章内容中的本地路径替换为云端URL
          newContent = newContent.replace(localPath, url);
        }
      });
      imagePromises.push(promise);
    }
  }

  await Promise.all(imagePromises);

  // 3. 返回包含更新后Frontmatter和内容的新Markdown字符串
  return matter.stringify(newContent, frontmatter);
}

module.exports = { preprocessMarkdown };
```

---

## 第4部分：核心脚本2：发布到各大平台

这个主脚本将调用预处理脚本，然后分别调用各个平台的发布逻辑。

### 4.1 发布到支持API的平台 (DEV.to, Hashnode, Medium)

我们将使用一个现成的、强大的CLI工具`crosspost`来简化这个过程。

**安装依赖**: `npm install node-fetch` (用于Hashnode GQL API)

```javascript
// publishers/apiPlatforms.js
const { execSync } = require(\'child_process\');
const fetch = require(\'node-fetch\');
const config = require(\'../config\');

// 使用crosspost CLI发布到DEV.to
async function publishToDevto(markdownContent) {
  console.log(\'\nPublishing to DEV.to...\');
  try {
    // crosspost需要文件路径，所以我们临时写入一个文件
    fs.writeFileSync(\'temp_article.md\', markdownContent);
    execSync(`npx crosspost temp_article.md --platforms devto --devtoKey ${config.platforms.devto.apiKey}`,
      { stdio: \'inherit\' });
    console.log(\'✅ Published to DEV.to successfully.\');
  } catch (error) {
    console.error(\'❌ Failed to publish to DEV.to:\', error.message);
  }
}

// 使用Hashnode GraphQL API发布
async function publishToHashnode(markdownContent, frontmatter) {
  console.log(\'\nPublishing to Hashnode...\');
  const mutation = `
    mutation CreatePublicationStory {
      createPublicationStory(publicationId: \"${config.platforms.hashnode.publicationId}\", input: {
        title: \"${frontmatter.title}\",
        contentMarkdown: \"${markdownContent.replace(/"/g, \'\\\"')}\",
        tags: [],
        slug: \"${frontmatter.slug}\",
        isRepublished: { originalArticleURL: \"${frontmatter.canonical_url}\" }
      }) { success, message }
    }
  `;
  try {
    const response = await fetch(\'https://api.hashnode.com\', {
      method: \'POST\',
      headers: { \'Content-Type\': \'application/json\', \'Authorization\': config.platforms.hashnode.apiKey },
      body: JSON.stringify({ query: mutation }),
    });
    const result = await response.json();
    if (result.data.createPublicationStory.success) {
      console.log(\'✅ Published to Hashnode successfully.\');
    } else {
      throw new Error(result.data.createPublicationStory.message);
    }
  } catch (error) {
    console.error(\'❌ Failed to publish to Hashnode:\', error.message);
  }
}

// ... 类似地，可以为Medium编写发布函数 ...

module.exports = { publishToDevto, publishToHashnode };
```

### 4.2 发布到无API的平台 (掘金, CSDN)

我们将使用`Puppeteer`，一个Node.js库，它能以编程方式控制一个真实的Chrome浏览器。

**安装依赖**: `npm install puppeteer`

```javascript
// publishers/browserPlatforms.js
const puppeteer = require(\'puppeteer\');
const config = require(\'../config\');

// 获取Cookie的说明：
// 1. 在Chrome中登录掘金/CSDN。
// 2. 按F12打开开发者工具，进入"网络(Network)"标签页。
// 3. 刷新页面，找到任意一个对主站发起的请求（如`juejin.cn`）。
// 4. 在请求头(Request Headers)中，找到`cookie:`行，复制其完整的字符串值。

async function publishToJuejin(title, markdownContent) {
  console.log(\'\nPublishing to Juejin...\');
  const browser = await puppeteer.launch({ headless: false }); // headless:false可以在调试时看到浏览器界面
  const page = await browser.newPage();

  try {
    // 1. 注入Cookie，实现免登录
    const cookies = config.browser.juejin.cookie.split(\' ; \').map(pair => {
      const [name, ...value] = pair.split(\'=\');
      return { name, value: value.join(\'=\'), domain: \'.juejin.cn\' };
    });
    await page.setCookie(...cookies);

    // 2. 打开创作页面
    await page.goto(\'https://juejin.cn/editor/drafts/new\', { waitUntil: \'networkidle2\' });

    // 3. 填充内容
    await page.type(\' .title-input\', title);
    await page.click(\' .bytemd-tippy-right > .bytemd-toolbar-icon:first-child\'); // 切换到Markdown编辑器
    await page.evaluate((content) => {
      const editor = document.querySelector(\' .bytemd-editor .CodeMirror\').CodeMirror;
      editor.setValue(content);
    }, markdownContent);

    // 4. 点击发布按钮 (此处选择器可能需要根据实际页面更新)
    await page.click(\' .publish-btn\');
    console.log(\'✅ Published to Juejin successfully (check browser for final confirmation).\');

  } catch (error) {
    console.error(\'❌ Failed to publish to Juejin:\', error.message);
  } finally {
    await browser.close();
  }
}

module.exports = { publishToJuejin };
```

---

## 第5部分：整合与执行

最后，我们创建一个主入口文件`publish.js`。

```javascript
// publish.js
const { preprocessMarkdown } = require(\'./preprocess\');
const { publishToDevto, publishToHashnode } = require(\'./publishers/apiPlatforms\');
const { publishToJuejin } = require(\'./publishers/browserPlatforms\');
const matter = require(\'gray-matter\');

async function main() {
  const filePath = process.argv[2];
  if (!filePath) {
    console.error(\'❌ Please provide the path to your markdown file.\');
    console.log(\'Usage: node publish.js <path-to-article.md>\');
    return;
  }

  console.log(\'🚀 Starting cross-posting process...\');

  // 1. 预处理Markdown
  const processedMarkdown = await preprocessMarkdown(filePath);
  const { data: frontmatter, content } = matter(processedMarkdown);

  // 2. 依次发布到各个平台
  await publishToDevto(processedMarkdown);
  await publishToHashnode(content, frontmatter);
  await publishToJuejin(frontmatter.title, content);
  // ... 调用发布到CSDN和其他平台的函数 ...

  console.log(\'\n✨ All publishing tasks are complete!\');
}

main();
```

**最终执行**: 
现在，你只需要在终端运行一个命令，就能启动整个自动化流程：
```bash
node publish.js /path/to/your/awesome-article.md
```

## 结论

自动化跨平台发布是一个复杂但回报率极高的工程。通过将流程拆解为“预处理”和“发布”两大环节，并针对不同平台的特性，灵活采用API或浏览器自动化等不同策略，我们可以构建一个强大的、属于自己的内容分发引擎(CDE)。投资时间打磨这样一套脚本，意味着你将从繁琐的重复劳动中永久解放出来，从而能更专注于内容创作本身——这才是你作为创作者最核心的价值所在。

## 参考资料
- [crosspost-cli (多平台发布CLI)](https://github.com/sinedied/crosspost-cli)
- [Puppeteer (浏览器自动化)](https://pptr.dev/)
- [Cloudinary Node.js SDK](https://cloudinary.com/documentation/node_integration)
- [gray-matter (Frontmatter解析库)](https://github.com/jonschlinkert/gray-matter)
